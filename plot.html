<!DOCTYPE html>
<meta charset="utf-8">
<style>

body {
  font: 15px sans-serif;
}

.axis path,
.axis line {
  fill: none;
  stroke: #000;
  shape-rendering: crispEdges;
}

.overlay {
  fill: none;
  pointer-events: all;
}

.focusMarkers circle {
  fill: none;
  stroke: steelblue;
}

path {
    fill:none;
    stroke:white;
    stroke-width:2px;
}

.area {
  fill: none;
  opacity: .2;
  clip-path: url(#clip);
}

.line {
  fill: none;
  stroke: steelblue;
  stroke-width: 1.5px;
}

.brush .extent {
  stroke: #fff;
  fill-opacity: .125;
  shape-rendering: crispEdges;
}


.path_prob_now {
    stroke:green;
}
.path_prob_5 {
    stroke:red;
}

.path_prob_15 {
    stroke:blue;
}

</style>


<body>
<script src="http://d3js.org/d3.v3.js"></script>



<script>

var margin = {top: 10, right: 10, bottom: 100, left: 40},
	margin2 = {top: 430, right: 10, bottom: 20, left: 40},
    width = 960 - margin.left - margin.right,
    height = 500 - margin.top - margin.bottom,
    height2 = 500 - margin2.top - margin2.bottom;


var xmain = d3.scale.linear().range([0, width]);
var	xbrush = d3.scale.linear().range([0, width]);
var ymain = d3.scale.linear().range([height, 0]);
var	ybrush = d3.scale.linear().range([height2, 0]);

var xAxis = d3.svg.axis().scale(xmain).orient("bottom");
var	xAxis2 = d3.svg.axis().scale(xbrush).orient("bottom");

var yAxis = d3.svg.axis()
    .scale(ymain)
    .orient("left");

var brush = d3.svg.brush()
    .x(xbrush)
    .on("brush", brushed);

      ///this is needed for the brushed part!		
function brushed() {
  xmain.domain(brush.empty() ? xbrush.domain() : brush.extent());
  //focus.selectAll("path.data").attr("d",function (col) { return areaMain(col)(data); })
   focus.selectAll("path.focusdata").attr("d", function (prob_when) { 
   		//console.log(prob_when);
   		//blah = areaMain(prob_when)(data);
      	return areaMain(prob_when)(the_data); 
    });


  focus.select(".x.axis").call(xAxis);
}


// var line = d3.svg.line()
//     .x(function(d) { return x(d.bmi); })
//     .y(function(d) { return y(d.prob_now); });

// var line10 = d3.svg.line()
//     .x(function(d) { return x(d.bmi); })
//     .y(function(d) { return y(d.prob_10); });

var areaMain = function (prob_when) {
	return d3.svg.area()
    	.interpolate("monotone")
    	.x(function(d) { return xmain(d.bmi); })
    	.y0(height)
    	.y1(function(d) { return ymain(d[prob_when]); 
    });
};


var areaBrush = function (prob_when) {
	return d3.svg.area()
    	.interpolate("monotone")
    	.x(function(d) { return xbrush(d.bmi); })
    	.y0(height2)
    	.y1(function(d) { return ybrush(d[prob_when]); 
    });
};





// //orginial code that works!!!
// var svg = d3.select("body").append("svg")
//     .attr("width", width + margin.left + margin.right)
//     .attr("height", height + margin.top + margin.bottom)
//   .append("g")
//     .attr("transform", "translate(" + margin.left + "," + margin.top + ")");




var svg = d3.select("body").append("svg")
    .attr("width", width + margin.left + margin.right)
    .attr("height", height + margin.top + margin.bottom);



svg.append("defs").append("clipPath")
    .attr("id", "clip")
  .append("rect")
    .attr("width", width)
    .attr("height", height);


var focus = svg.append("g")
    .attr("class", "focus")
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

var context = svg.append("g")
    .attr("class", "context")
    .attr("transform", "translate(" + margin2.left + "," + margin2.top + ")");


pdata = ['prob_now', 'prob_5','prob_15'];

var the_data = []

d3.tsv("data.tsv", function(error, data) {
  
  the_data = data;

  data.forEach(function(d) {
    d.bmi = +d.bmi;
    d.prob_now = +d.prob;
    d.prob_5 = +d.prob*.7;
    d.prob_15 = +d.prob*1.2;
  });

  xmain.domain(d3.extent(data, function(d) { return d.bmi; }));
  ymain.domain(d3.extent(data, function(d) { return d.prob_15; }));
  xbrush.domain(xmain.domain());
  ybrush.domain(ymain.domain());


  focus.selectAll('path')
    .data(pdata)
  .enter()
    .append('path')
    .attr('clip-path', 'url(#clip)')
    //.attr('fill','none')
    .attr('d', function (prob_when) {
      return areaMain(prob_when)(data);
    })
    .attr('class', function (prob_when) {
      return "path_" + prob_when + " focusdata";
    });



  context.selectAll('path')
    .data(['prob_now', 'prob_5','prob_15'])
  .enter()
    .append('path')
    .attr('fill','none')
    .attr('d', function (prob_when) {
      return areaBrush(prob_when)(data);
    })
    .attr('class', function (prob_when) {
      return "path_" + prob_when;
    });




  focus.append("g")
      .attr("class", "x axis")
      .attr("transform", "translate(0," + height + ")")
      .call(xAxis)
    .append("text")
    	.attr("class", "x label")
    	.attr("x", width*.99)
    	.attr("y", -6)
    	.style("text-anchor", "end")
        .text("BMI");

  focus.append("g")
      .attr("class", "y axis")
      .call(yAxis)
    .append("text")
      .attr("class", "y label")
      .attr("transform", "rotate(-90)")
      .attr("y", 6)
      .attr("dy", ".75em")
      .style("text-anchor", "end")
      .text("Prob(DM)");

  context.append("g")
      .attr("class", "x axis")
      .attr("transform", "translate(0," + height2 + ")")
      .call(xAxis2);

  context.append("g")
      .attr("class", "x brush")
      .call(brush)
    .selectAll("rect")
      .attr("y", -6)
      .attr("height", height2*10);




  // // THIS CODE SHOWS THE VALUES OM THE LINE    
  // var bisectBMI = d3.bisector(function(d) { return d.bmi; }).left
  // var formatProb = d3.format(",.2f")
  // var formatBMI = d3.format(",.1f")


  // //var focusMarkers = svg.append("g")
  // var focusMarkers = focus.append("g")
  //     .attr("class", "focusMarkers")
  //     .style("display", "none");

  // focusMarkers.append("circle")
  //     .attr("r", 6);

  // focusMarkers.append("text")
  //     .attr("x", 9)
  //     .attr("dy", ".35em");

  // //svg.append("rect")
  // focus.append("rect")
	 //  .attr("class", "overlay")
	 //  .attr("width", width)
	 //  .attr("height", height)
	 //  .on("mouseover", function() { focusMarkers.style("display", null); })
	 //  .on("mouseout", function() { focusMarkers.style("display", "none"); })
	 //  .on("mousemove", mousemove);

  // function mousemove() {
  //   var x0 = xmain.invert(d3.mouse(this)[0]),
  //       i = bisectBMI(data, x0, 1),
  //       d0 = data[i - 1],
  //       d1 = data[i],
  //       d = x0 - d0.bmi > d1.bmi - x0 ? d1 : d0;
  //   focusMarkers.attr("transform", "translate(" + xmain(d.bmi) + "," + ymain(d.prob_now) + ")");
  //   focusMarkers.select("text").text("BMI: " + formatBMI(d.bmi) + " Prob: " + formatProb(d.prob_now));
  // }



});











</script>